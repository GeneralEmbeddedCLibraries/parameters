// Copyright (c) 2021 Ziga Miklosic
// All Rights Reserved
// This software is under MIT licence (https://opensource.org/licenses/MIT)
////////////////////////////////////////////////////////////////////////////////
/**
*@file      par_cfg.c
*@brief     Configuration for device parameters
*@author    Ziga Miklosic
*@date      22.05.2021
*@version	V1.0.1
*/
////////////////////////////////////////////////////////////////////////////////
/**
*@addtogroup PAR_CFG
* @{ <!-- BEGIN GROUP -->
*
* 	Configuration for device parameters
*
* 	User shall put code inside inside code block start with
* 	"USER_CODE_BEGIN" and with end of "USER_CODE_END".
*/
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Includes
////////////////////////////////////////////////////////////////////////////////
#include "par_cfg.h"
#include "parameters/src/par.h"

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Variables
////////////////////////////////////////////////////////////////////////////////

/**
 *	Parameters definitions
 *
 *	@brief
 *
 *	Each defined parameter has following properties:
 *
 *		i) 		Parameter ID: 	Unique parameter identification number. ID shall not be duplicated.
 *		ii) 	Name:			Parameter name. Max. length of 32 chars.
 *		iii)	Min:			Parameter minimum value. Min value must be less than max value.
 *		iv)		Max:			Parameter maximum value. Max value must be more than min value.
 *		v)		Def:			Parameter default value. Default value must lie between interval: [min, max]
 *		vi)		Unit:			In case parameter shows physical value. Max. length of 32 chars.
 *		vii)	Data type:		Parameter data type. Supported types: uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t and float32_t
 *		viii)	Access:			Access type visible from external device such as PC. Either ReadWrite or ReadOnly.
 *		ix)		Persistence:	Tells if parameter value is being written into NVM.
 *
 *
 *	@note	User shall fill up wanted parameter definitions!
 */
static const par_cfg_t g_par_table[ePAR_NUM_OF] =
{

	// USER CODE BEGIN...

	// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//	ID			Name						Min 				Max 				Def 					Unit				Data type				PC Access					Persistent
	// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	{	.id = 0, 	.name = "Test_u8",	 		.min.u8 = 0,		.max.u8 = 10,		.def.u8 = 8,			.unit = "n/a",		.type = ePAR_TYPE_U8,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},
	{	.id = 1, 	.name = "Test_i8", 			.min.i8 = -10,		.max.i8 = 100,		.def.i8 = -8,			.unit = "n/a",		.type = ePAR_TYPE_I8,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},

	{	.id = 2, 	.name = "Test_u16",	 		.min.u16 = 0,		.max.u16 = 10,		.def.u16 = 3,			.unit = "n/a",		.type = ePAR_TYPE_U16,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},
	{	.id = 3, 	.name = "Test_i16", 		.min.i16 = -10,		.max.i16 = 100,		.def.i16 = -5,			.unit = "n/a",		.type = ePAR_TYPE_I16,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},

	{	.id = 4, 	.name = "Test_u32", 		.min.u32 = 0,		.max.u32 = 10,		.def.u32 = 10,			.unit = "n/a",		.type = ePAR_TYPE_U32,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},
	{	.id = 5, 	.name = "Test_i32", 		.min.i32 = -10,		.max.i32 = 100,		.def.i32 = -10,			.unit = "n/a",		.type = ePAR_TYPE_I32,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},

	{	.id = 6, 	.name = "Test_f32", 		.min.f32 = -10,		.max.f32 = 100,		.def.f32 = -1.123,		.unit = "n/a",		.type = ePAR_TYPE_F32,	.access = ePAR_ACCESS_RW, 	.persistant = true 		},

	// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	// USER CODE END...
};

/**
 * 	Table size in bytes
 */
static const uint32_t gu32_par_table_size = sizeof( g_par_table );

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/**
*		Get parameter configuration table
*
* @return		pointer to configuration table
*/
////////////////////////////////////////////////////////////////////////////////
const void * par_cfg_get_table(void)
{
	return (const par_cfg_t*) &g_par_table;
}

////////////////////////////////////////////////////////////////////////////////
/**
*		Get configuration table size in bytes
*
* @return	gu32_par_table_size	- Size of table in bytes
*/
////////////////////////////////////////////////////////////////////////////////
uint32_t par_cfg_get_table_size(void)
{
	return gu32_par_table_size;
}

////////////////////////////////////////////////////////////////////////////////
/**
* @} <!-- END GROUP -->
*/
////////////////////////////////////////////////////////////////////////////////
